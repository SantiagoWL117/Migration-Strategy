## menuca_v3.cities — Migration Plan

### Purpose
Migrate canonical city reference data with geocoding (lat/lng) and timezone information from V2 `cities` (primary source) to `menuca_v3.cities`. Backfill from V1 `cities` if needed. This table depends on `menuca_v3.provinces` and will be referenced by restaurant locations, delivery areas, and user addresses.

---

### Source vs Target Mapping (Evidence)

**Sources consulted:**

**V2 schema `cities` (PRIMARY SOURCE):**
```291:310:Database/Legacy schemas/menuca_v2 structure.sql
CREATE TABLE `cities` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(50) DEFAULT NULL,
  `displayName` varchar(125) DEFAULT NULL,
  `province_id` smallint DEFAULT '0',
  `country` char(3) NOT NULL DEFAULT 'ca',
  `lat` decimal(13,10) DEFAULT NULL,
  `lng` decimal(13,10) DEFAULT NULL,
  `timezone` varchar(45) DEFAULT NULL,
  `language_id` tinyint DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `province_id` (`province_id`)
) ENGINE=InnoDB AUTO_INCREMENT=110 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
```

**V1 schema `cities` (BACKFILL SOURCE):**
```340:357:Database/Legacy schemas/menuca_v1 structure.sql
CREATE TABLE `cities` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `displayName` varchar(125) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `county` int unsigned NOT NULL DEFAULT '0',
  `country` int unsigned NOT NULL DEFAULT '0',
  `lat` varchar(45) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `lng` varchar(45) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `timezone` varchar(45) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=118 DEFAULT CHARSET=latin1 ROW_FORMAT=DYNAMIC;
```

**Target table in V3:**
```sql
-- From menuca_v3.sql (inferred structure)
CREATE TABLE IF NOT EXISTS menuca_v3.cities (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR(125) NOT NULL,
  display_name VARCHAR(125),
  province_id SMALLINT NOT NULL REFERENCES menuca_v3.provinces(id),
  lat NUMERIC(13,10),
  lng NUMERIC(13,10),
  timezone VARCHAR(50),
  UNIQUE(name, province_id)
);

CREATE INDEX IF NOT EXISTS idx_cities_province ON menuca_v3.cities(province_id);
CREATE INDEX IF NOT EXISTS idx_cities_coordinates ON menuca_v3.cities(lat, lng);
```

**Note:** The cities table is referenced by `menuca_v3.restaurant_locations.city_id`. Country and language_id fields are not migrated (handled at application level).

---

### Field Mapping

**Source: V2 `cities` (PRIMARY) with V1 `cities` for backfill**

| Target Column | V2 Source Column | V1 Source Column | Transform / Notes |
|---|---|---|---|
| **id** | n/a | n/a | INTEGER GENERATED BY DEFAULT AS IDENTITY. Let PostgreSQL auto-generate. |
| **name** | `cities.name` | `cities.name` | Direct copy. VARCHAR(50) → VARCHAR(125). Prefer V2 when available. |
| **display_name** | `cities.displayName` | `cities.displayName` | Direct copy. VARCHAR(125). User-friendly display name. |
| **province_id** | `cities.province_id` | `cities.county` | **CRITICAL MAPPING:** V1 uses `county` (int) → must map to V3 provinces.id via V1 counties lookup. V2 uses `province_id` (smallint) → map to V3 provinces.id via V2 provinces lookup. |
| **lat** | `cities.lat` | `cities.lat` | V2: DECIMAL(13,10) direct copy. V1: VARCHAR(45) → cast to NUMERIC(13,10). Validate range: -90 to 90. |
| **lng** | `cities.lng` | `cities.lng` | V2: DECIMAL(13,10) direct copy. V1: VARCHAR(45) → cast to NUMERIC(13,10). Validate range: -180 to 180. |
| **timezone** | `cities.timezone` | `cities.timezone` | Direct copy. VARCHAR(45) → VARCHAR(50). IANA format (e.g., 'America/Toronto'). |

**Key Mapping Challenges:**
1. **Province ID Resolution:**
   - V1 `county` → lookup in V1 counties table → match to V3 provinces by name/short_name
   - V2 `province_id` → lookup in V2 provinces table → match to V3 provinces by name/short_name
   
2. **Coordinate Type Conversion:**
   - V1 stores as VARCHAR(45) - may contain invalid data
   - Need to validate numeric conversion
   - Handle NULL, empty strings, non-numeric values

3. **Missing Timezones:**
   - Some cities may have NULL timezone
   - Derive from province when possible (Ontario → 'America/Toronto', Quebec → 'America/Montreal')

**Out of Scope (columns not migrated):**
- `country`: Not migrated (V2 char(3), V1 int reference) - all assumed CA/US, handle at app level
- `language_id`: Not migrated to cities table

---

### Data Insights & Quality Checks

**Expected Data:**
- Canadian cities: Toronto, Montreal, Vancouver, Calgary, Ottawa, etc.
- V2: ~110 cities (based on AUTO_INCREMENT=110)
- V1: ~118 cities (based on AUTO_INCREMENT=118)
- Total unique in V3: ~110-120 cities (after deduplication)

**Data Quality Issues Identified:**
1. ⚠️ V1 coordinates stored as VARCHAR - may have invalid data
2. ⚠️ Missing timezones for some cities
3. ⚠️ V1 `county` field needs careful mapping to V3 province_id
4. ⚠️ Potential duplicate cities across V1/V2
5. ⚠️ V2 `province_id` default value is 0 (invalid FK) - need to handle

**Province Mapping Strategy:**
```sql
-- Build V1 county → V3 province lookup
CREATE TEMP TABLE v1_county_to_v3_province AS
SELECT 
  v1c.id as v1_county_id,
  v3p.id as v3_province_id,
  v1c.name as v1_county_name,
  v3p.name as v3_province_name
FROM staging.v1_counties v1c
JOIN menuca_v3.provinces v3p 
  ON LOWER(TRIM(v1c.name)) = LOWER(TRIM(v3p.name))
  OR LOWER(TRIM(v1c.short_name)) = LOWER(TRIM(v3p.short_name));

-- Build V2 province → V3 province lookup
CREATE TEMP TABLE v2_province_to_v3_province AS
SELECT 
  v2p.id as v2_province_id,
  v3p.id as v3_province_id,
  v2p.name as v2_province_name,
  v3p.name as v3_province_name
FROM staging.v2_provinces v2p
JOIN menuca_v3.provinces v3p 
  ON LOWER(TRIM(v2p.name)) = LOWER(TRIM(v3p.name))
  OR LOWER(TRIM(v2p.short_name)) = LOWER(TRIM(v3p.short_name));
```

---

### Extract Step

#### 1. Field Mapping ✅ (Complete - see above)

#### 2. Review Tables (USER ACTION REQUIRED)
- ✅ V2 `cities` identified as primary source
- ✅ V1 `cities` identified for backfill
- ⚠️ **ACTION:** User should verify no other city/location tables exist in V1/V2

#### 3. Add Data Dumps (USER ACTION REQUIRED)

**Required dumps for analysis:**
```sql
-- V2 cities (PRIMARY SOURCE)
SELECT * FROM menuca_v2.cities ORDER BY id;

-- V1 cities (BACKFILL SOURCE)
SELECT * FROM menuca_v1.cities ORDER BY id;
```

**Expected dump location:** `/Database/Location & Geography Entity/CSV/`
- `menuca_v2_cities.csv`
- `menuca_v1_cities.csv`

#### 4. Preconditions (Step 0) ✅

```sql
-- Verify provinces table is populated (CRITICAL DEPENDENCY)
SELECT COUNT(*) as province_count FROM menuca_v3.provinces;
-- Expected: > 0 (provinces must be migrated first)

-- Verify V3 cities table exists
SELECT EXISTS (
  SELECT FROM information_schema.tables 
  WHERE table_schema = 'menuca_v3' 
  AND table_name = 'cities'
);

-- If not exists, create:
CREATE TABLE IF NOT EXISTS menuca_v3.cities (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR(125) NOT NULL,
  display_name VARCHAR(125),
  province_id SMALLINT NOT NULL REFERENCES menuca_v3.provinces(id),
  lat NUMERIC(13,10),
  lng NUMERIC(13,10),
  timezone VARCHAR(50),
  UNIQUE(name, province_id)
);

CREATE INDEX IF NOT EXISTS idx_cities_province ON menuca_v3.cities(province_id);
CREATE INDEX IF NOT EXISTS idx_cities_coordinates ON menuca_v3.cities(lat, lng);

-- Verify structure
\d menuca_v3.cities
```

#### 5. Extract to CSV (USER ACTION REQUIRED)

**Export V2 cities data:**
```sql
-- Export from V2 MySQL
SELECT 
  id,
  name,
  displayName,
  province_id,
  country,
  lat,
  lng,
  timezone,
  language_id
FROM menuca_v2.cities
ORDER BY id
INTO OUTFILE '/path/to/menuca_v2_cities.csv'
FIELDS TERMINATED BY ',' 
ENCLOSED BY '"'
LINES TERMINATED BY '\n';
```

**Export V1 cities data:**
```sql
-- Export from V1 MySQL
SELECT 
  id,
  name,
  displayName,
  county,
  country,
  lat,
  lng,
  timezone
FROM menuca_v1.cities
ORDER BY id
INTO OUTFILE '/path/to/menuca_v1_cities.csv'
FIELDS TERMINATED BY ',' 
ENCLOSED BY '"'
LINES TERMINATED BY '\n';
```

#### 6. Build Staging Tables (Step 1)

```sql
-- Create staging schema if not exists
CREATE SCHEMA IF NOT EXISTS staging;

-- Staging table for V2 cities (primary source)
DROP TABLE IF EXISTS staging.v2_cities;
CREATE TABLE staging.v2_cities (
  legacy_v2_id INTEGER,
  name VARCHAR(125),
  display_name VARCHAR(125),
  province_id SMALLINT,
  country CHAR(3),
  lat NUMERIC(13,10),
  lng NUMERIC(13,10),
  timezone VARCHAR(50),
  language_id SMALLINT
);

-- Staging table for V1 cities (backfill source)
DROP TABLE IF EXISTS staging.v1_cities;
CREATE TABLE staging.v1_cities (
  legacy_v1_id INTEGER,
  name VARCHAR(125),
  display_name VARCHAR(125),
  county INTEGER,
  country INTEGER,
  lat VARCHAR(45),  -- Keep as VARCHAR initially for validation
  lng VARCHAR(45),  -- Keep as VARCHAR initially for validation
  timezone VARCHAR(50)
);

-- Load CSV data (USER will provide CSV files)
\COPY staging.v2_cities FROM '/path/to/menuca_v2_cities.csv' CSV HEADER;
\COPY staging.v1_cities FROM '/path/to/menuca_v1_cities.csv' CSV HEADER;
```

---

### Transform Step

#### 1. Verify Format Discrepancies

```sql
-- A) Check V2 cities for invalid province_id (should reference existing provinces)
SELECT c.legacy_v2_id, c.name, c.province_id
FROM staging.v2_cities c
LEFT JOIN menuca_v3.provinces p ON p.id = c.province_id
WHERE p.id IS NULL OR c.province_id = 0;
-- Flag cities with province_id = 0 or non-existent province

-- B) Check V1 cities for invalid county FK
SELECT c.legacy_v1_id, c.name, c.county
FROM staging.v1_cities c
LEFT JOIN staging.v1_counties v1c ON v1c.legacy_v1_id = c.county
WHERE v1c.legacy_v1_id IS NULL OR c.county = 0;
-- Flag cities with invalid county reference

-- C) Check V1 coordinate format (VARCHAR → NUMERIC conversion)
SELECT 
  legacy_v1_id, 
  name, 
  lat, 
  lng,
  CASE 
    WHEN lat ~ '^-?[0-9]+\.?[0-9]*$' THEN 'Valid'
    ELSE 'Invalid'
  END as lat_validity,
  CASE 
    WHEN lng ~ '^-?[0-9]+\.?[0-9]*$' THEN 'Valid'
    ELSE 'Invalid'
  END as lng_validity
FROM staging.v1_cities
WHERE lat IS NOT NULL AND TRIM(lat) != ''
  AND (lat !~ '^-?[0-9]+\.?[0-9]*$' OR lng !~ '^-?[0-9]+\.?[0-9]*$');
-- Should return 0 rows if all coordinates are valid numbers

-- D) Check for NULL/missing coordinates
SELECT 
  'V2' as source, 
  COUNT(*) FILTER (WHERE lat IS NULL OR lng IS NULL) as missing_coords
FROM staging.v2_cities
UNION ALL
SELECT 
  'V1' as source,
  COUNT(*) FILTER (WHERE lat IS NULL OR TRIM(lat) = '' OR lng IS NULL OR TRIM(lng) = '')
FROM staging.v1_cities;

-- E) Check for missing timezones
SELECT 
  'V2' as source,
  COUNT(*) FILTER (WHERE timezone IS NULL OR TRIM(timezone) = '') as missing_tz
FROM staging.v2_cities
UNION ALL
SELECT 
  'V1' as source,
  COUNT(*) FILTER (WHERE timezone IS NULL OR TRIM(timezone) = '')
FROM staging.v1_cities;

-- F) Check for duplicate cities within same source
SELECT name, province_id, COUNT(*) as duplicate_count
FROM staging.v2_cities
WHERE name IS NOT NULL
GROUP BY name, province_id
HAVING COUNT(*) > 1;

-- G) Compare V1 vs V2 - find overlaps and differences
SELECT 
  COALESCE(v2.name, v1.name) as city_name,
  v2.province_id as v2_province,
  v1.county as v1_county,
  CASE 
    WHEN v2.name IS NULL THEN 'Only in V1'
    WHEN v1.name IS NULL THEN 'Only in V2'
    ELSE 'In both'
  END as status
FROM staging.v2_cities v2
FULL OUTER JOIN staging.v1_cities v1 
  ON LOWER(TRIM(v2.name)) = LOWER(TRIM(v1.name));
```

#### 2. Data Cleaning & Transformation

```sql
-- A) Normalize city names
UPDATE staging.v2_cities
SET name = INITCAP(TRIM(name))
WHERE name != INITCAP(TRIM(name));

UPDATE staging.v1_cities
SET name = INITCAP(TRIM(name))
WHERE name != INITCAP(TRIM(name));

-- B) Convert V1 coordinates from VARCHAR to NUMERIC (create helper columns)
ALTER TABLE staging.v1_cities 
  ADD COLUMN lat_numeric NUMERIC(13,10),
  ADD COLUMN lng_numeric NUMERIC(13,10);

UPDATE staging.v1_cities
SET 
  lat_numeric = NULLIF(lat, '')::NUMERIC(13,10),
  lng_numeric = NULLIF(lng, '')::NUMERIC(13,10)
WHERE lat ~ '^-?[0-9]+\.?[0-9]*$' 
  AND lng ~ '^-?[0-9]+\.?[0-9]*$';

-- C) Validate coordinate ranges
SELECT legacy_v1_id, name, lat_numeric, lng_numeric
FROM staging.v1_cities
WHERE lat_numeric IS NOT NULL 
  AND (lat_numeric < -90 OR lat_numeric > 90 
       OR lng_numeric < -180 OR lng_numeric > 180);
-- Should return 0 rows - all coordinates in valid range

-- D) Handle missing timezones - derive from province
-- First, create province-to-timezone mapping
CREATE TEMP TABLE province_default_timezone AS
SELECT DISTINCT ON (p.id)
  p.id as province_id,
  p.name as province_name,
  CASE 
    WHEN p.short_name IN ('ON') THEN 'America/Toronto'
    WHEN p.short_name IN ('QC') THEN 'America/Montreal'
    WHEN p.short_name IN ('BC') THEN 'America/Vancouver'
    WHEN p.short_name IN ('AB') THEN 'America/Edmonton'
    WHEN p.short_name IN ('MB') THEN 'America/Winnipeg'
    WHEN p.short_name IN ('SK') THEN 'America/Regina'
    WHEN p.short_name IN ('NS', 'NB', 'PE') THEN 'America/Halifax'
    WHEN p.short_name IN ('NL') THEN 'America/St_Johns'
    WHEN p.short_name IN ('YT') THEN 'America/Whitehorse'
    WHEN p.short_name IN ('NT', 'NU') THEN 'America/Yellowknife'
    ELSE 'America/Toronto'  -- default fallback
  END as default_timezone
FROM menuca_v3.provinces p;

-- Apply default timezone to V2 cities with missing timezone
UPDATE staging.v2_cities v2
SET timezone = ptz.default_timezone
FROM province_default_timezone ptz
WHERE v2.province_id = ptz.province_id
  AND (v2.timezone IS NULL OR TRIM(v2.timezone) = '');

-- E) Build province mapping tables
CREATE TEMP TABLE v1_city_province_mapping AS
SELECT 
  v1c.legacy_v1_id,
  v1c.name as city_name,
  v1c.county as v1_county_id,
  v1co.name as v1_county_name,
  v3p.id as v3_province_id,
  v3p.name as v3_province_name
FROM staging.v1_cities v1c
LEFT JOIN staging.v1_counties v1co ON v1co.legacy_v1_id = v1c.county
LEFT JOIN menuca_v3.provinces v3p 
  ON LOWER(TRIM(v1co.name)) = LOWER(TRIM(v3p.name))
  OR LOWER(TRIM(v1co.short_name)) = LOWER(TRIM(v3p.short_name));

CREATE TEMP TABLE v2_city_province_mapping AS
SELECT 
  v2c.legacy_v2_id,
  v2c.name as city_name,
  v2c.province_id as v2_province_id,
  v2p.name as v2_province_name,
  v3p.id as v3_province_id,
  v3p.name as v3_province_name
FROM staging.v2_cities v2c
LEFT JOIN staging.v2_provinces v2p ON v2p.legacy_v2_id = v2c.province_id
LEFT JOIN menuca_v3.provinces v3p 
  ON LOWER(TRIM(v2p.name)) = LOWER(TRIM(v3p.name))
  OR LOWER(TRIM(v2p.short_name)) = LOWER(TRIM(v3p.short_name));

-- F) Check for unmapped provinces (should be 0)
SELECT * FROM v2_city_province_mapping WHERE v3_province_id IS NULL;
SELECT * FROM v1_city_province_mapping WHERE v3_province_id IS NULL;
```

---

### Load Step

#### Transform and Upsert (Step 2) — Idempotent

```sql
BEGIN;

-- Ensure unique constraint and indexes exist
CREATE UNIQUE INDEX IF NOT EXISTS u_city_name_province 
  ON menuca_v3.cities (name, province_id);

CREATE INDEX IF NOT EXISTS idx_cities_province 
  ON menuca_v3.cities(province_id);
  
CREATE INDEX IF NOT EXISTS idx_cities_coordinates 
  ON menuca_v3.cities(lat, lng);

-- Load V2 cities (PRIMARY SOURCE)
WITH v2_cities_normalized AS (
  SELECT 
    v2c.name,
    v2c.display_name,
    pm.v3_province_id as province_id,
    v2c.lat,
    v2c.lng,
    COALESCE(NULLIF(TRIM(v2c.timezone), ''), ptz.default_timezone) as timezone
  FROM staging.v2_cities v2c
  JOIN v2_city_province_mapping pm ON pm.legacy_v2_id = v2c.legacy_v2_id
  LEFT JOIN province_default_timezone ptz ON ptz.province_id = pm.v3_province_id
  WHERE v2c.name IS NOT NULL 
    AND TRIM(v2c.name) != ''
    AND pm.v3_province_id IS NOT NULL
)
INSERT INTO menuca_v3.cities (name, display_name, province_id, lat, lng, timezone)
SELECT 
  INITCAP(TRIM(name)) as name,
  TRIM(display_name) as display_name,
  province_id,
  lat,
  lng,
  timezone
FROM v2_cities_normalized
ON CONFLICT (name, province_id) 
DO UPDATE SET
  display_name = COALESCE(EXCLUDED.display_name, menuca_v3.cities.display_name),
  lat = COALESCE(EXCLUDED.lat, menuca_v3.cities.lat),
  lng = COALESCE(EXCLUDED.lng, menuca_v3.cities.lng),
  timezone = COALESCE(EXCLUDED.timezone, menuca_v3.cities.timezone);

-- Backfill from V1 cities (only if not already in V3)
WITH v1_cities_normalized AS (
  SELECT 
    v1c.name,
    v1c.display_name,
    pm.v3_province_id as province_id,
    v1c.lat_numeric as lat,
    v1c.lng_numeric as lng,
    COALESCE(NULLIF(TRIM(v1c.timezone), ''), ptz.default_timezone) as timezone
  FROM staging.v1_cities v1c
  JOIN v1_city_province_mapping pm ON pm.legacy_v1_id = v1c.legacy_v1_id
  LEFT JOIN province_default_timezone ptz ON ptz.province_id = pm.v3_province_id
  WHERE v1c.name IS NOT NULL 
    AND TRIM(v1c.name) != ''
    AND pm.v3_province_id IS NOT NULL
    -- Only insert if not already present from V2
    AND NOT EXISTS (
      SELECT 1 FROM menuca_v3.cities v3c
      WHERE LOWER(TRIM(v3c.name)) = LOWER(TRIM(v1c.name))
        AND v3c.province_id = pm.v3_province_id
    )
)
INSERT INTO menuca_v3.cities (name, display_name, province_id, lat, lng, timezone)
SELECT 
  INITCAP(TRIM(name)) as name,
  TRIM(display_name) as display_name,
  province_id,
  lat,
  lng,
  timezone
FROM v1_cities_normalized
ON CONFLICT (name, province_id) 
DO NOTHING;  -- Skip if already exists (shouldn't happen due to NOT EXISTS filter)

COMMIT;
```

**Idempotency:** This query can be run multiple times safely. The `ON CONFLICT` clauses ensure existing records are updated or skipped as appropriate.

---

### Post-load Normalization (Step 3) — Optional

```sql
-- A) Ensure all names are properly capitalized
UPDATE menuca_v3.cities
SET name = INITCAP(name)
WHERE name != INITCAP(name);

-- B) Handle cities with missing coordinates (flag for manual review)
SELECT id, name, province_id, lat, lng
FROM menuca_v3.cities
WHERE lat IS NULL OR lng IS NULL;
-- ACTION: If any rows, research coordinates and update manually

-- C) Verify all cities have valid province FK
SELECT c.id, c.name, c.province_id
FROM menuca_v3.cities c
LEFT JOIN menuca_v3.provinces p ON p.id = c.province_id
WHERE p.id IS NULL;
-- Should return 0 rows

-- D) Ensure all cities have timezone
UPDATE menuca_v3.cities c
SET timezone = ptz.default_timezone
FROM province_default_timezone ptz
WHERE c.province_id = ptz.province_id
  AND (c.timezone IS NULL OR TRIM(c.timezone) = '');
```

---

### Verification Step (Step 4)

#### A) Row Count Verification

```sql
-- Compare counts across sources and target
SELECT 'V2 Source' as source, COUNT(*) as row_count 
FROM staging.v2_cities
UNION ALL
SELECT 'V1 Source' as source, COUNT(*) 
FROM staging.v1_cities
UNION ALL
SELECT 'V3 Target' as source, COUNT(*) 
FROM menuca_v3.cities
ORDER BY source;

-- Expected Outcome: 
--   V3 count should be >= V2 count (primary source)
--   V3 count may be <= V1 + V2 (some overlap expected)
```

#### B) Data Integrity Checks

```sql
-- Check for duplicate cities (should be 0)
SELECT name, province_id, COUNT(*) as duplicate_count
FROM menuca_v3.cities
GROUP BY name, province_id
HAVING COUNT(*) > 1;
-- Expected Outcome: 0 rows (unique constraint prevents duplicates)

-- Check for orphaned cities (invalid province FK) - should be 0
SELECT c.id, c.name, c.province_id
FROM menuca_v3.cities c
LEFT JOIN menuca_v3.provinces p ON p.id = c.province_id
WHERE p.id IS NULL;
-- Expected Outcome: 0 rows (FK constraint should prevent this)

-- Check for missing required fields
SELECT 
  COUNT(*) FILTER (WHERE name IS NULL OR TRIM(name) = '') as missing_name,
  COUNT(*) FILTER (WHERE province_id IS NULL) as missing_province,
  COUNT(*) FILTER (WHERE lat IS NULL) as missing_lat,
  COUNT(*) FILTER (WHERE lng IS NULL) as missing_lng,
  COUNT(*) FILTER (WHERE timezone IS NULL OR TRIM(timezone) = '') as missing_timezone
FROM menuca_v3.cities;
-- Expected Outcome: 
--   missing_name = 0 (required)
--   missing_province = 0 (required, FK constraint)
--   missing_lat/lng = acceptable if minimal
--   missing_timezone = 0 (should all be populated or derived)

-- Validate coordinate ranges
SELECT id, name, lat, lng
FROM menuca_v3.cities
WHERE lat IS NOT NULL 
  AND (lat < -90 OR lat > 90 OR lng < -180 OR lng > 180);
-- Expected Outcome: 0 rows (coordinates must be in valid range)

-- Check timezone format (IANA format)
SELECT DISTINCT timezone, COUNT(*) as city_count
FROM menuca_v3.cities
GROUP BY timezone
ORDER BY city_count DESC;
-- Expected Outcome: All timezones should be valid IANA format
--   (America/Toronto, America/Montreal, America/Vancouver, etc.)
```

#### C) Distribution Analysis

```sql
-- Cities per province
SELECT 
  p.name as province,
  p.short_name,
  COUNT(c.id) as city_count
FROM menuca_v3.provinces p
LEFT JOIN menuca_v3.cities c ON c.province_id = p.id
GROUP BY p.id, p.name, p.short_name
ORDER BY city_count DESC;
-- Expected Outcome: Ontario and Quebec should have most cities

-- Cities by timezone
SELECT timezone, COUNT(*) as city_count
FROM menuca_v3.cities
GROUP BY timezone
ORDER BY city_count DESC;
-- Expected Outcome: America/Toronto and America/Montreal should dominate
```

#### D) Sample Data Verification

```sql
-- Top 20 cities for manual review
SELECT 
  c.id,
  c.name,
  c.display_name,
  p.name as province,
  c.lat,
  c.lng,
  c.timezone
FROM menuca_v3.cities c
JOIN menuca_v3.provinces p ON p.id = c.province_id
ORDER BY c.name
LIMIT 20;
-- Expected Outcome: Major cities visible (Toronto, Montreal, Vancouver, etc.)

-- Check specific known cities
SELECT 
  c.name,
  p.name as province,
  c.lat,
  c.lng,
  c.timezone
FROM menuca_v3.cities c
JOIN menuca_v3.provinces p ON p.id = c.province_id
WHERE c.name IN ('Toronto', 'Montreal', 'Vancouver', 'Ottawa', 'Calgary')
ORDER BY c.name;
-- Expected Outcome: All major cities present with correct data
```

#### E) Cross-Reference Validation

```sql
-- Cities in V2 but not in V3 (potential migration failures)
SELECT v2c.legacy_v2_id, v2c.name, v2c.province_id
FROM staging.v2_cities v2c
WHERE NOT EXISTS (
  SELECT 1 FROM menuca_v3.cities v3c
  JOIN v2_city_province_mapping pm ON pm.v3_province_id = v3c.province_id
  WHERE LOWER(TRIM(v3c.name)) = LOWER(TRIM(v2c.name))
    AND pm.legacy_v2_id = v2c.legacy_v2_id
);
-- Expected Outcome: 0 rows (all V2 cities should be migrated)
-- If any rows: investigate why they failed (likely invalid province_id)

-- Cities in V1 but not in V3 (acceptable if also not in V2)
SELECT v1c.legacy_v1_id, v1c.name, v1c.county
FROM staging.v1_cities v1c
WHERE NOT EXISTS (
  SELECT 1 FROM menuca_v3.cities v3c
  WHERE LOWER(TRIM(v3c.name)) = LOWER(TRIM(v1c.name))
)
AND NOT EXISTS (
  SELECT 1 FROM staging.v2_cities v2c
  WHERE LOWER(TRIM(v2c.name)) = LOWER(TRIM(v1c.name))
);
-- Expected Outcome: 0-few rows (V1-only cities, may be deprecated)
```

---

### Execution Order

1. ✅ **Verify Provinces Complete** - Must have menuca_v3.provinces populated
2. **Run Preconditions (Step 0)** - Verify V3 cities table exists
3. **USER ACTION: Export CSV** (Step 5) - Extract V2 cities and V1 cities to CSV
4. **Create Staging Tables (Step 1)** - Load CSV into staging.v2_cities and staging.v1_cities
5. **Run Transform Checks** - Verify format discrepancies, validate coordinates, map provinces
6. **Build Province Mappings** - Create temp tables for V1/V2 → V3 province mapping
7. **Execute Transform/Upsert (Step 2)** - Load cities into menuca_v3.cities
8. **Run Post-load Normalization (Step 3)** - Cleanup and derive missing timezones
9. **Execute Verification (Step 4)** - Run all verification queries
10. **Remediate** if any issues found, steps are idempotent
11. **Document** any discrepancies or decisions made
12. **Update Memory Bank** - Mark migration complete

---

### Notes

1. **Critical Dependency:** Provinces must be migrated and verified BEFORE cities migration.

2. **Province Mapping Complexity:**
   - V1 `county` (int) → V1 counties table → match by name/short_name → V3 provinces.id
   - V2 `province_id` (smallint) → V2 provinces table → match by name/short_name → V3 provinces.id

3. **Coordinate Type Conversion:**
   - V1 uses VARCHAR(45) - validate and convert to NUMERIC(13,10)
   - V2 uses DECIMAL(13,10) - direct copy

4. **Timezone Handling:**
   - Missing timezones derived from province
   - Default timezone mapping by province short_name

5. **Data Source Priority:**
   - V2 cities loaded first (primary source)
   - V1 cities backfill only if not in V2
   - Deduplication by (name, province_id)

6. **Blocking Migrations:**
   - Restaurant Management (restaurant_locations) needs cities
   - Delivery Operations (delivery_areas) needs cities
   - Users & Access (user addresses) needs cities

---

### Success Criteria

✅ All V2 cities migrated to V3
✅ V1 cities backfilled (non-duplicates)
✅ No duplicate cities in V3 (per province)
✅ No NULL names or province_id
✅ All coordinates in valid range (-90 to 90, -180 to 180)
✅ All cities have timezone (populated or derived)
✅ All province_id FKs are valid
✅ Major cities present (Toronto, Montreal, Vancouver, etc.)
✅ Ready for restaurant locations migration

---

### Next Steps

After successful cities migration:
1. ✅ Update memory bank with completion status
2. ✅ Mark tasks lg-009, lg-010, lg-011 complete
3. ✅ Location & Geography entity migration COMPLETE
4. → Unblock **Restaurant Management** entity (can now complete restaurant_locations)
5. → Unblock **Delivery Operations** entity (can reference canonical cities)
6. → Unblock **Users & Access** entity (can reference canonical cities)

---

### Troubleshooting

**Issue: Cities with province_id = 0 in V2**
```sql
-- Find problematic cities
SELECT * FROM staging.v2_cities WHERE province_id = 0;

-- Manual resolution required: research correct province for each city
-- Update staging table and re-run load step
```

**Issue: V1 coordinates not numeric**
```sql
-- Find invalid coordinates
SELECT * FROM staging.v1_cities 
WHERE lat !~ '^-?[0-9]+\.?[0-9]*$' OR lng !~ '^-?[0-9]+\.?[0-9]*$';

-- Manual resolution: research coordinates for affected cities
-- Or exclude from migration if deprecated
```

**Issue: Province mapping failures**
```sql
-- Check unmapped provinces
SELECT * FROM v2_city_province_mapping WHERE v3_province_id IS NULL;
SELECT * FROM v1_city_province_mapping WHERE v3_province_id IS NULL;

-- Resolution: ensure provinces migration is complete
-- Or manually map province names that don't match
```
