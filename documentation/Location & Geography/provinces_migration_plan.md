## menuca_v3.provinces — Migration Plan

### Purpose
Migrate canonical province/state reference data from V2 `provinces` (authoritative source) to `menuca_v3.provinces`. This is a foundational table required by the cities table and ultimately by restaurant locations, delivery areas, and user addresses. V1 `counties` table serves as validation reference only.

---

### Source vs Target Mapping (Evidence)

**Sources consulted:**

**V2 schema `provinces` (AUTHORITATIVE):**
```947:960:Database/Legacy schemas/menuca_v2 structure.sql
CREATE TABLE `provinces` (
  `id` smallint NOT NULL AUTO_INCREMENT,
  `name` varchar(125) NOT NULL,
  `short_name` char(3) CHARACTER SET latin1 COLLATE latin1_swedish_ci DEFAULT NULL,
  `language_id` tinyint(1) DEFAULT '1',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=29 DEFAULT CHARSET=utf8mb3;
```

**V1 schema `counties` (VALIDATION ONLY):**
```399:413:Database/Legacy schemas/menuca_v1 structure.sql
CREATE TABLE `counties` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(45) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `country` int unsigned NOT NULL DEFAULT '0',
  `short_name` varchar(3) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  `lang` char(2) NOT NULL DEFAULT 'en',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=29 DEFAULT CHARSET=latin1;
```

**Target table in V3:**
```sql
-- From menuca_v3.sql (inferred from cities FK)
CREATE TABLE IF NOT EXISTS menuca_v3.provinces (
  id SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR(125) NOT NULL,
  short_name CHAR(3),
  UNIQUE(name, short_name)
);
```

**Note:** The V3 provinces table is referenced by `menuca_v3.cities.province_id` as shown in the schema. This is a foundational reference table with minimal fields.

---

### Field Mapping

**Source: V2 `provinces` (PRIMARY) with V1 `counties` for validation**

| Target Column | V2 Source Column | V1 Source Column | Transform / Notes |
|---|---|---|---|
| **id** | n/a | n/a | SMALLINT GENERATED BY DEFAULT AS IDENTITY. Let PostgreSQL auto-generate. |
| **name** | `provinces.name` | `counties.name` | Direct copy from V2. VARCHAR(125). Validate against V1 for consistency. |
| **short_name** | `provinces.short_name` | `counties.short_name` | Direct copy from V2. CHAR(3) - province/state abbreviation (e.g., 'ON', 'QC', 'BC'). |

**Key Notes:**
- V2 is the authoritative source (~29 rows expected based on AUTO_INCREMENT=29)
- V1 `counties` has same structure but uses deprecated naming convention
- V1 `country` and `lang` fields are not migrated to V3 (not needed)
- Unique constraint on `(name, short_name)` in V3 prevents duplicates

**Out of Scope (V1 columns not migrated):**
- `country`: Not needed in V3 (all provinces are Canadian/North American)
- `lang`: Not migrated (language handling is done at application level)
- V1 `language_id` from V2: Not migrated to provinces table

---

### Data Insights & Quality Checks

**Expected Data:**
- Canadian provinces: ON, QC, BC, AB, MB, SK, NS, NB, PE, NL, YT, NT, NU (~13 rows)
- US states if supported: NY, CA, FL, TX, etc. (~10-16 rows if present)
- Total expected: 13-29 rows based on AUTO_INCREMENT values

**Data Quality Checks:**
1. All provinces should have `short_name` (2-3 character code)
2. No duplicate `(name, short_name)` combinations
3. Names should be properly capitalized (e.g., "Ontario" not "ontario")
4. V1 and V2 province lists should match or V2 should be superset of V1

---

### Extract Step

#### 1. Field Mapping ✅ (Complete - see above)

#### 2. Review Tables (USER ACTION REQUIRED)
- ✅ V2 `provinces` identified as authoritative source
- ✅ V1 `counties` identified for validation
- ⚠️ **ACTION:** User should verify no other province/state tables exist in V1/V2

#### 3. Add Data Dumps (USER ACTION REQUIRED)
**Required dumps for analysis:**
```sql
-- V2 provinces (PRIMARY SOURCE)
SELECT * FROM menuca_v2.provinces ORDER BY id;

-- V1 counties (VALIDATION)
SELECT id, name, short_name, lang FROM menuca_v1.counties ORDER BY id;
```

**Expected dump location:** `/Database/Location & Geography Entity/CSV/`
- `menuca_v2_provinces.csv`
- `menuca_v1_counties.csv` (validation only)

#### 4. Preconditions (Step 0) ✅

Verify V3 provinces table exists:

```sql
-- Check if table exists
SELECT EXISTS (
  SELECT FROM information_schema.tables 
  WHERE table_schema = 'menuca_v3' 
  AND table_name = 'provinces'
);

-- If not exists, create:
CREATE TABLE IF NOT EXISTS menuca_v3.provinces (
  id SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR(125) NOT NULL,
  short_name CHAR(3),
  UNIQUE(name, short_name)
);

-- Verify structure
\d menuca_v3.provinces
```

#### 5. Extract to CSV (USER ACTION REQUIRED)
**Export V2 provinces data:**
```sql
-- Export from V2 MySQL
SELECT 
  id,
  name,
  short_name,
  language_id
FROM menuca_v2.provinces
ORDER BY id
INTO OUTFILE '/path/to/menuca_v2_provinces.csv'
FIELDS TERMINATED BY ',' 
ENCLOSED BY '"'
LINES TERMINATED BY '\n';
```

**Export V1 counties for validation:**
```sql
-- Export from V1 MySQL
SELECT 
  id,
  name,
  short_name,
  lang
FROM menuca_v1.counties
ORDER BY id
INTO OUTFILE '/path/to/menuca_v1_counties.csv'
FIELDS TERMINATED BY ',' 
ENCLOSED BY '"'
LINES TERMINATED BY '\n';
```

#### 6. Build Staging Tables (Step 1)

```sql
-- Create staging schema if not exists
CREATE SCHEMA IF NOT EXISTS staging;

-- Staging table for V2 provinces (primary source)
DROP TABLE IF EXISTS staging.v2_provinces;
CREATE TABLE staging.v2_provinces (
  legacy_v2_id SMALLINT,
  name VARCHAR(125),
  short_name CHAR(3),
  language_id SMALLINT
);

-- Staging table for V1 counties (validation only)
DROP TABLE IF EXISTS staging.v1_counties;
CREATE TABLE staging.v1_counties (
  legacy_v1_id INTEGER,
  name VARCHAR(125),
  short_name CHAR(3),
  lang CHAR(2)
);

-- Load CSV data (USER will provide CSV files)
-- Example PostgreSQL COPY commands:
\COPY staging.v2_provinces FROM '/path/to/menuca_v2_provinces.csv' CSV HEADER;
\COPY staging.v1_counties FROM '/path/to/menuca_v1_counties.csv' CSV HEADER;
```

---

### Transform Step

#### 1. Verify Format Discrepancies

```sql
-- Check for NULL or empty names in V2
SELECT * FROM staging.v2_provinces 
WHERE name IS NULL OR TRIM(name) = '';

-- Check for NULL or empty short_name in V2
SELECT * FROM staging.v2_provinces 
WHERE short_name IS NULL OR TRIM(short_name) = '';

-- Check for inconsistent capitalization
SELECT name, short_name 
FROM staging.v2_provinces
WHERE name != INITCAP(name) OR short_name != UPPER(short_name);

-- Check for duplicates in V2
SELECT name, short_name, COUNT(*) 
FROM staging.v2_provinces
GROUP BY name, short_name
HAVING COUNT(*) > 1;

-- Compare V1 vs V2 - find discrepancies
SELECT 
  COALESCE(v2.name, v1.name) as province_name,
  v2.short_name as v2_short,
  v1.short_name as v1_short,
  CASE 
    WHEN v2.name IS NULL THEN 'Missing in V2'
    WHEN v1.name IS NULL THEN 'Missing in V1'
    WHEN v2.short_name != v1.short_name THEN 'Short name mismatch'
    ELSE 'OK'
  END as status
FROM staging.v2_provinces v2
FULL OUTER JOIN staging.v1_counties v1 
  ON LOWER(v2.name) = LOWER(v1.name);
```

#### 2. Data Cleaning (if needed based on discrepancies)

```sql
-- Normalize names to proper case
UPDATE staging.v2_provinces
SET name = INITCAP(TRIM(name))
WHERE name != INITCAP(TRIM(name));

-- Normalize short_name to uppercase
UPDATE staging.v2_provinces
SET short_name = UPPER(TRIM(short_name))
WHERE short_name != UPPER(TRIM(short_name));

-- Remove duplicates (keep first occurrence by legacy_v2_id)
DELETE FROM staging.v2_provinces
WHERE legacy_v2_id NOT IN (
  SELECT MIN(legacy_v2_id)
  FROM staging.v2_provinces
  GROUP BY name, short_name
);
```

---

### Load Step

#### Transform and Upsert (Step 2) — Idempotent

```sql
BEGIN;

-- Ensure unique constraint exists
CREATE UNIQUE INDEX IF NOT EXISTS u_province_name_short 
  ON menuca_v3.provinces (name, short_name);

-- Upsert provinces from V2 staging
INSERT INTO menuca_v3.provinces (name, short_name)
SELECT 
  INITCAP(TRIM(name)) as name,
  UPPER(TRIM(short_name)) as short_name
FROM staging.v2_provinces
WHERE name IS NOT NULL 
  AND TRIM(name) != ''
  AND short_name IS NOT NULL
  AND TRIM(short_name) != ''
ON CONFLICT (name, short_name) 
DO UPDATE SET
  -- No updates needed if exists, just ensure idempotency
  name = EXCLUDED.name,
  short_name = EXCLUDED.short_name;

COMMIT;
```

**Idempotency:** This query can be run multiple times safely. The `ON CONFLICT` clause ensures existing records are not duplicated.

---

### Post-load Normalization (Step 3) — Optional

```sql
-- Verify no NULL values
SELECT id, name, short_name
FROM menuca_v3.provinces
WHERE name IS NULL OR short_name IS NULL;

-- If any NULL short_names found, manual review required
-- (Should not happen if V2 data is clean)

-- Ensure all names are properly formatted
UPDATE menuca_v3.provinces
SET name = INITCAP(name)
WHERE name != INITCAP(name);

-- Ensure all short_names are uppercase
UPDATE menuca_v3.provinces  
SET short_name = UPPER(short_name)
WHERE short_name != UPPER(short_name);
```

---

### Verification Step (Step 4)

#### A) Row Count Verification

```sql
-- Compare counts across sources and target
SELECT 'V2 Source' as source, COUNT(*) as row_count 
FROM staging.v2_provinces
UNION ALL
SELECT 'V1 Validation' as source, COUNT(*) 
FROM staging.v1_counties
UNION ALL
SELECT 'V3 Target' as source, COUNT(*) 
FROM menuca_v3.provinces;

-- Expected: V3 count should equal V2 count (V2 is authoritative)
-- V1 count may be different (validation only)
```

**Expected Outcome:** V3 row count should match V2 row count exactly.

#### B) Data Integrity Checks

```sql
-- Check for duplicates (should be 0)
SELECT name, short_name, COUNT(*) as duplicate_count
FROM menuca_v3.provinces
GROUP BY name, short_name
HAVING COUNT(*) > 1;

-- Expected Outcome: 0 rows (unique constraint prevents duplicates)

-- Check for NULL values (should be 0)
SELECT 
  COUNT(*) FILTER (WHERE name IS NULL) as null_names,
  COUNT(*) FILTER (WHERE short_name IS NULL) as null_short_names,
  COUNT(*) FILTER (WHERE name IS NULL OR short_name IS NULL) as any_nulls
FROM menuca_v3.provinces;

-- Expected Outcome: All counts should be 0

-- Verify all provinces have short_name length of 2-3 chars
SELECT id, name, short_name, LENGTH(short_name) as len
FROM menuca_v3.provinces
WHERE LENGTH(short_name) NOT BETWEEN 2 AND 3;

-- Expected Outcome: 0 rows (all short_names should be 2-3 chars)
```

#### C) Cross-Reference with V1 (Validation)

```sql
-- Find provinces in V2/V3 but not in V1 (informational only)
SELECT p.id, p.name, p.short_name
FROM menuca_v3.provinces p
LEFT JOIN staging.v1_counties v1 
  ON LOWER(p.name) = LOWER(v1.name)
WHERE v1.name IS NULL;

-- Expected Outcome: May have 0+ rows if V2 has newer provinces not in V1

-- Find provinces in V1 but not in V2/V3 (potential missing data)
SELECT v1.legacy_v1_id, v1.name, v1.short_name
FROM staging.v1_counties v1
LEFT JOIN menuca_v3.provinces p 
  ON LOWER(v1.name) = LOWER(p.name)
WHERE p.name IS NULL;

-- Expected Outcome: Should be 0 rows (V2 should have all V1 provinces)
-- If any rows found, investigate and potentially add to V3
```

#### D) Sample Data Verification

```sql
-- Display all provinces for manual review
SELECT id, name, short_name
FROM menuca_v3.provinces
ORDER BY name;

-- Expected Outcome: List of Canadian provinces/territories and potentially US states
-- Example expected rows:
--   Ontario, ON
--   Quebec, QC
--   British Columbia, BC
--   Alberta, AB
--   etc.

-- Count by short_name length (should all be 2-3)
SELECT LENGTH(short_name) as len, COUNT(*) as count
FROM menuca_v3.provinces
GROUP BY LENGTH(short_name)
ORDER BY len;

-- Expected Outcome: Most/all should have length 2 or 3
```

#### E) Foreign Key Dependency Check

```sql
-- Verify provinces are ready for cities table (forward-looking)
SELECT 
  COUNT(*) as total_provinces,
  COUNT(DISTINCT short_name) as unique_short_names,
  COUNT(DISTINCT name) as unique_names
FROM menuca_v3.provinces;

-- Expected Outcome: 
--   total_provinces = unique_short_names = unique_names
--   (all provinces have unique identifiers)

-- Preview for cities migration (should be 0 cities at this point)
SELECT p.name as province, COUNT(c.id) as city_count
FROM menuca_v3.provinces p
LEFT JOIN menuca_v3.cities c ON c.province_id = p.id
GROUP BY p.id, p.name
ORDER BY p.name;

-- Expected Outcome: All city_count should be 0 (cities not migrated yet)
```

---

### Execution Order

1. **Run Preconditions (Step 0)** - Verify V3 provinces table exists
2. **USER ACTION: Export CSV** (Step 5) - Extract V2 provinces and V1 counties to CSV
3. **Create Staging Tables (Step 1)** - Load CSV into staging.v2_provinces and staging.v1_counties
4. **Run Transform Checks** - Verify format discrepancies, clean data if needed
5. **Execute Transform/Upsert (Step 2)** - Load provinces into menuca_v3.provinces
6. **Run Post-load Normalization (Step 3)** - Optional cleanup
7. **Execute Verification (Step 4)** - Run all verification queries
8. **Remediate** if any issues found, steps are idempotent
9. **Document** any discrepancies or decisions made
10. **Proceed to cities migration** once provinces verification passes

---

### Notes

1. **Single Authoritative Source:** V2 `provinces` is the primary source. V1 `counties` is validation only.

2. **Minimal Fields:** This is a simple reference table with only 3 fields (id, name, short_name).

3. **No Dependencies:** Provinces table has no foreign key dependencies - it's foundational.

4. **Blocking Migration:** Cities migration cannot proceed until provinces are complete and verified.

5. **Data Volume:** Small table (~13-29 rows), quick migration.

6. **Idempotency:** All load steps can be re-run safely without creating duplicates.

---

### Success Criteria

✅ All V2 provinces migrated to V3
✅ No duplicate provinces in V3
✅ No NULL values in name or short_name
✅ All short_names are 2-3 characters, uppercase
✅ All names are properly capitalized
✅ V1 validation confirms no missing provinces
✅ Ready for cities migration (FK dependency satisfied)

---

### Next Steps

After successful provinces migration:
1. ✅ Update memory bank with completion status
2. ✅ Mark task lg-007 complete, lg-008 complete
3. → Proceed to **cities migration** (task lg-005)
4. → Cities will reference menuca_v3.provinces.id as foreign key
