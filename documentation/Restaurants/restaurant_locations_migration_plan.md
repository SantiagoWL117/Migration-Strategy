## Migration Plan: menuca_v3.restaurant_locations

Scope: Load address/geo/contact fields from V1/V2 restaurants into `menuca_v3.restaurant_locations`, linking each to `menuca_v3.restaurants` by legacy ids.

### 0) Preconditions
```sql
-- Ensure menuca_v3 database exists
-- menuca_v3.restaurants should already be created.
CREATE SCHEMA IF NOT EXISTS menuca_v3;

-- Provinces (canonical) - based on staging.provinces_v2 headers
DROP TABLE IF EXISTS menuca_v3.provinces;
CREATE TABLE menuca_v3.provinces (
  id smallint PRIMARY KEY,
  name varchar(125) NOT NULL,
  nom_francaise varchar(125),
  short_name char(3) NOT NULL
);
CREATE UNIQUE INDEX IF NOT EXISTS u_provinces_name_en ON menuca_v3.provinces (lower(name));
CREATE UNIQUE INDEX IF NOT EXISTS u_provinces_short_name ON menuca_v3.provinces (lower(short_name));

-- Cities (canonical) - aligned with staging.cities_v1 and staging.cities_v2
DROP TABLE IF EXISTS menuca_v3.cities;
CREATE TABLE menuca_v3.cities (
  id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name varchar(125) NOT NULL,
  display_name varchar(125),
  province_id smallint,
  CONSTRAINT cities_province_id_fkey FOREIGN KEY (province_id) REFERENCES menuca_v3.provinces(id),
  lat numeric(13,10),
  lng numeric(13,10),
  timezone varchar(50)
);
CREATE UNIQUE INDEX IF NOT EXISTS u_cities_name_province ON menuca_v3.cities (lower(name), COALESCE(province_id, 0));
CREATE INDEX IF NOT EXISTS idx_cities_province_id ON menuca_v3.cities (province_id);
 
-- Restaurant locations (final target)
DROP TABLE IF EXISTS menuca_v3.restaurant_locations;
CREATE TABLE menuca_v3.restaurant_locations (
  id bigserial NOT NULL,
  uuid uuid NOT NULL DEFAULT extensions.uuid_generate_v4 (),
  restaurant_id bigint NOT NULL,
  is_primary boolean NOT NULL DEFAULT true,
  street_address character varying(255),
  city_id integer,
  province_id integer,
  postal_code character varying(15),
  latitude numeric(13, 10),
  longitude numeric(13, 10),
  phone character varying(30),
  email character varying(255),
  is_active boolean NOT NULL DEFAULT true,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone,
  CONSTRAINT restaurant_locations_pkey PRIMARY KEY (id),
  CONSTRAINT restaurant_locations_uuid_key UNIQUE (uuid),
  CONSTRAINT restaurant_locations_city_id_fkey FOREIGN KEY (city_id) REFERENCES menuca_v3.cities (id) ON UPDATE RESTRICT ON DELETE RESTRICT NOT VALID,
  CONSTRAINT restaurant_locations_restaurant_id_fkey FOREIGN KEY (restaurant_id) REFERENCES menuca_v3.restaurants (id) ON DELETE CASCADE
) TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_locations_restaurant ON menuca_v3.restaurant_locations USING btree (restaurant_id) TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS idx_locations_coords ON menuca_v3.restaurant_locations USING btree (latitude, longitude) TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS idx_locations_city_id ON menuca_v3.restaurant_locations USING btree (city_id) TABLESPACE pg_default;

CREATE TRIGGER trg_locations_updated_at BEFORE
UPDATE ON menuca_v3.restaurant_locations FOR EACH ROW
EXECUTE FUNCTION menuca_v3.set_updated_at ();
```

### 1) Staging tables
```sql
CREATE SCHEMA IF NOT EXISTS staging;

DROP TABLE IF EXISTS staging.v1_restaurants_locations;
CREATE TABLE staging.v1_restaurants_locations (
  id            integer PRIMARY KEY,
  address       text,
  city          text,
  province      text,
  zip           text,
  latitude      text,
  longitude     text,
  phone         text,
  main_email    text,
  active        text,      -- 'Y'/'N'
  updated_at    timestamptz
);

DROP TABLE IF EXISTS staging.v2_restaurants_locations;
CREATE TABLE staging.v2_restaurants_locations (
  id            integer PRIMARY KEY,
  v1_id         integer,
  address       text,
  city_id       integer,
  province_id   integer,
  zip           text,
  lat           numeric(13,10),
  lng           numeric(13,10),
  phone         text,
  email         text,
  active        text,        -- 'y'/'n'
  updated_at    timestamptz
);

-- Cities/Provinces staging (from menuca_v3 staging location & geography.sql)
DROP TABLE IF EXISTS staging.cities_v1;
CREATE TABLE staging.cities_v1 (
  id integer PRIMARY KEY,
  name varchar(125),
  display_name varchar(125),
  lat text,
  lng text,
  timezone varchar(50),
  province_id smallint
);

DROP TABLE IF EXISTS staging.cities_v2;
CREATE TABLE staging.cities_v2 (
  id integer PRIMARY KEY,
  name varchar(125),
  province_id smallint,
  lat numeric(13,10),
  lng numeric(13,10),
  timezone varchar(50)
);
CREATE INDEX IF NOT EXISTS idx_cities_v2_province_id ON staging.cities_v2 (province_id);

DROP TABLE IF EXISTS staging.provinces_v2;
CREATE TABLE staging.provinces_v2 (
  id smallint PRIMARY KEY,
  "name (english)" varchar(125) NOT NULL,
  "nom(francais)" varchar(125),
  short_name char(3)
);
```

### 2) Load from CSV (Workbench exports)
 Load CSV files straight to Supabase using the 'Import data from CSV' option.

### 3) Populate provinces and cities (from staging)
```sql
BEGIN;

-- Ensure unique indexes to support idempotent upserts
CREATE UNIQUE INDEX IF NOT EXISTS u_provinces_name ON menuca_v3.provinces (lower(name));
CREATE UNIQUE INDEX IF NOT EXISTS u_cities_name_province ON menuca_v3.cities (lower(name), COALESCE(province_id, 0));

-- Upsert provinces from v2 (preserve canonical ids)
INSERT INTO menuca_v3.provinces (id, name, nom_francaise, short_name)
SELECT p.id,
       p."name (english)",
       p."nom(francais)",
       lower(p.short_name)
FROM staging.provinces_v2 p
ON CONFLICT (id) DO UPDATE
SET name = EXCLUDED.name,
    nom_francaise = EXCLUDED.nom_francaise,
    short_name = EXCLUDED.short_name;

-- Insert v2 cities mapped to v3 provinces; skip if already present by (name, province)
WITH p AS (
  SELECT sp.id AS src_province_id, sp.id AS v3_province_id
  FROM staging.provinces_v2 sp
)
INSERT INTO menuca_v3.cities (name, display_name, province_id, lat, lng, timezone)
SELECT
  c.name,
  NULL::varchar(125) AS display_name,
  p.v3_province_id,
  c.lat,
  c.lng,
  c.timezone
FROM staging.cities_v2 c
LEFT JOIN p ON p.src_province_id = c.province_id
LEFT JOIN menuca_v3.cities mc
  ON lower(mc.name) = lower(c.name)
 AND mc.province_id IS NOT DISTINCT FROM p.v3_province_id
WHERE mc.id IS NULL;

-- For names that already exist in menuca_v3.cities, prefer province from v2
WITH p AS (
  SELECT sp.id AS v3_province_id, sp."name (english)" AS prov_name
  FROM staging.provinces_v2 sp
)
UPDATE menuca_v3.cities mc
SET province_id = p.v3_province_id
FROM staging.cities_v2 c
JOIN p ON TRUE
WHERE lower(mc.name) = lower(c.name)
  AND p.v3_province_id = c.province_id
  AND (mc.province_id IS DISTINCT FROM p.v3_province_id);

-- Insert remaining v1 cities (no reliable province in v1 CSV); avoid duplicates by name
INSERT INTO menuca_v3.cities (name, display_name, province_id, lat, lng, timezone)
SELECT DISTINCT
  c.name,
  c.display_name,
  NULL::smallint AS province_id,
  NULLIF(c.lat,'')::numeric,
  NULLIF(c.lng,'')::numeric,
  c.timezone
FROM staging.cities_v1 c
LEFT JOIN menuca_v3.cities mc ON lower(mc.name) = lower(c.name)
WHERE mc.id IS NULL;

COMMIT;
```

### 4) Transform and upsert
```sql
BEGIN;

-- Ensure phone column can hold normalized values
ALTER TABLE menuca_v3.restaurant_locations
ALTER COLUMN phone TYPE varchar(30) USING phone::varchar(30);

-- A) Insert primary location per V1 row that exists in v3.restaurants
INSERT INTO menuca_v3.restaurant_locations (
  restaurant_id, is_primary, street_address, city_id, province_id, postal_code,
  latitude, longitude, phone, email, is_active, created_at, updated_at
)
SELECT
  r.id AS restaurant_id,
  TRUE AS is_primary,
  NULLIF(TRIM(v1.address),'') AS street_address,
  c3.id AS city_id,
  NULL::integer AS province_id,  -- v1 province text deferred
  NULLIF(TRIM(v1.zip),'') AS postal_code,
  NULLIF(v1.latitude,'')::numeric,
  NULLIF(v1.longitude,'')::numeric,
  CASE
    WHEN v1.phone ~ '^\(\d{3}\) \d{3}-\d{4}$' THEN v1.phone
    ELSE NULL
  END AS phone,
  NULLIF(TRIM(v1.main_email),'') AS email,
  CASE WHEN v1.active IN ('Y','y','1') THEN TRUE ELSE FALSE END AS is_active,
  NOW() AS created_at,
  v1.updated_at AS updated_at
FROM staging.v1_restaurants_locations v1
JOIN menuca_v3.restaurants r ON r.legacy_v1_id = v1.id
LEFT JOIN staging.cities_v1 cv1
  ON (v1.city ~ '^[0-9]+$') AND cv1.id = v1.city::integer
LEFT JOIN menuca_v3.cities c3
  ON c3.name IS NOT NULL AND lower(c3.name) = lower(cv1.name)
ON CONFLICT DO NOTHING;

-- B) Upsert/enrich via V2 by v1_id or by v2 id link, prefer V2 values when present
INSERT INTO menuca_v3.restaurant_locations (
  restaurant_id, is_primary, street_address, city_id, province_id, postal_code,
  latitude, longitude, phone, email, is_active, created_at, updated_at
)
SELECT
  r.id AS restaurant_id,
  TRUE AS is_primary,
  COALESCE(NULLIF(TRIM(v2.address),''), rl.street_address) AS street_address,
  COALESCE(c3v2.id, rl.city_id) AS city_id,
  COALESCE(mp.id, rl.province_id) AS province_id,
  COALESCE(NULLIF(TRIM(v2.zip),''), rl.postal_code) AS postal_code,
  COALESCE(v2.lat, rl.latitude) AS latitude,
  COALESCE(v2.lng, rl.longitude) AS longitude,
  COALESCE(
    CASE
      WHEN v2.phone ~ '^\(\d{3}\) \d{3}-\d{4}$' THEN v2.phone
      ELSE NULL
    END,
    rl.phone
  ) AS phone,
  COALESCE(NULLIF(TRIM(v2.email),''), rl.email) AS email,
  COALESCE(CASE WHEN v2.active IN ('y','Y','1') THEN TRUE ELSE FALSE END, rl.is_active) AS is_active,
  COALESCE(rl.created_at, NOW()) AS created_at,
  COALESCE(v2.updated_at, rl.updated_at) AS updated_at
FROM staging.v2_restaurants_locations v2
JOIN menuca_v3.restaurants r
  ON (v2.v1_id IS NOT NULL AND r.legacy_v1_id = v2.v1_id)
  OR (r.legacy_v2_id = v2.id)
LEFT JOIN menuca_v3.restaurant_locations rl ON rl.restaurant_id = r.id AND rl.is_primary = TRUE
LEFT JOIN staging.cities_v2 cv2 ON cv2.id = v2.city_id
LEFT JOIN staging.provinces_v2 sp ON sp.id = v2.province_id
LEFT JOIN menuca_v3.provinces mp ON mp.id = sp.id
LEFT JOIN menuca_v3.cities c3v2 ON lower(c3v2.name) = lower(cv2.name) AND c3v2.province_id = mp.id
ON CONFLICT DO NOTHING;

COMMIT;
```

### 5) Verification
```sql
-- Count locations per restaurant (expect 1 primary row per restaurant)
SELECT restaurant_id, COUNT(*) AS locs
FROM menuca_v3.restaurant_locations
GROUP BY restaurant_id
ORDER BY locs DESC
LIMIT 50;

-- Missing links check
SELECT v1.id
FROM staging.v1_restaurants_locations v1
LEFT JOIN menuca_v3.restaurants r ON r.legacy_v1_id = v1.id
WHERE r.id IS NULL
LIMIT 50;

-- Null address sanity
SELECT COUNT(*) AS no_address
FROM menuca_v3.restaurant_locations
WHERE street_address IS NULL AND (latitude IS NULL OR longitude IS NULL);
```

### Notes
- V1 province is free-text; normalize later if you add a province reference.
- City from V2 uses `city_id`; join to your cities table when available. Otherwise keep V1 text city.
- All imports treat empty CSV fields as NULL and cast coordinates safely.


