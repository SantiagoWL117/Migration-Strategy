## menuca_v3.restaurant_admin_users — Migration Plan

### Purpose
Migrate restaurant administrator/owner login accounts from V1 `restaurant_admins` to `menuca_v3.restaurant_admin_users`. V2 has a different `admin_users` structure that represents global platform administrators (not restaurant-specific), so this migration focuses exclusively on V1 as the authoritative source for restaurant-level admin users.

### Source vs Target Mapping (evidence)

Sources consulted:

- V1 schema `restaurant_admins`:
```1177:1198:Database/Legacy schemas/menuca_v1 structure.sql
CREATE TABLE `restaurant_admins` (
  `id` int NOT NULL AUTO_INCREMENT,
  `admin_user_id` int unsigned DEFAULT NULL,
  `password` varchar(255) ...,
  `fname` varchar(20) ...,
  `lname` varchar(50) ...,
  `email` varchar(50) ...,
  `user_type` enum('r','g') DEFAULT NULL COMMENT '''Restaurant, Global''',
  `restaurant` int NOT NULL,
  `lastlogin` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `activeUser` enum('1','0') NOT NULL DEFAULT '1',
  `loginCount` int unsigned NOT NULL DEFAULT '0',
  `allowed_restaurants` blob NOT NULL,
  `showAllStats` enum('y','n') NOT NULL DEFAULT 'n',
  `fb_token` varchar(255) NOT NULL,
  `showOrderManagement` enum('y','n') NOT NULL DEFAULT 'n',
  `sendStatement` enum('y','n') NOT NULL DEFAULT 'n',
  `sendStatementTo` varchar(125) NOT NULL,
  `allowAr` enum('y','n') NOT NULL DEFAULT 'n',
  `showClients` enum('y','n') DEFAULT 'y',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1075 DEFAULT CHARSET=latin1;
```

- V2 schema `admin_users` (NOT APPLICABLE - global platform admins):
```71:92:Database/Legacy schemas/menuca_v2 structure.sql
CREATE TABLE `admin_users` (
  `id` int NOT NULL AUTO_INCREMENT,
  `preferred_language` tinyint DEFAULT '1',
  `fname` varchar(45) ...,
  `lname` varchar(45) ...,
  `email` varchar(45) ...,
  `password` varchar(125) ...,
  `group` int NOT NULL,
  `receive_statements` enum('y','n') DEFAULT 'n',
  `phone` varchar(20) DEFAULT NULL,
  `active` enum('y','n') DEFAULT 'y',
  `override_restaurants` enum('y','n') DEFAULT 'n',
  `settings` json DEFAULT NULL,
  ...
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=85 DEFAULT CHARSET=utf8mb3;
```
Note: V2 `admin_users` is linked to restaurants via `admin_users_restaurants` junction table and represents **platform-level** administrators with group-based permissions, NOT restaurant owners/admins. This is out of scope.

- Target table in v3:
```146:170:Database/Legacy schemas/menuca_v3.sql
CREATE TABLE IF NOT EXISTS menuca_v3.restaurant_admin_users (
  id bigint NOT NULL,
  uuid uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
  restaurant_id bigint NOT NULL,
  user_type character varying(1) DEFAULT 'r'::character varying,
  first_name character varying(50),
  last_name character varying(50),
  email character varying(255) NOT NULL,
  password_hash character varying(255),
  last_login timestamp with time zone,
  login_count integer DEFAULT 0,
  is_active boolean DEFAULT true NOT NULL,
  send_statement boolean DEFAULT false,
  created_at timestamp with time zone DEFAULT now() NOT NULL,
  updated_at timestamp with time zone
);
...
CREATE UNIQUE INDEX IF NOT EXISTS u_admin_email_per_restaurant 
  ON menuca_v3.restaurant_admin_users USING btree (restaurant_id, email);
```

Mapping convention from `restaurant-management-mapping.md` confirms V1-only source for restaurant admin users.

### Field Mapping

**Source: V1 `restaurant_admins` ONLY**

| Target Column | V1 Source Column | Transform / Notes |
|---|---|---|
| **id** | n/a | BIGSERIAL generated by `restaurant_admin_users_id_seq` |
| **uuid** | n/a | `uuid_generate_v4()` default |
| **restaurant_id** | `restaurant_admins.restaurant` | Resolve via FK join: `menuca_v3.restaurants.legacy_v1_id = restaurant_admins.restaurant` → use `menuca_v3.restaurants.id`. **CRITICAL:** V1 has records with `restaurant = 0` (user_type='g' global admins) - these should be filtered out or handled separately. |
| **user_type** | `restaurant_admins.user_type` | Copy directly; enum('r','g') → varchar(1). Default 'r' if NULL. 'r' = restaurant owner/admin, 'g' = global (rare in this context). **Note:** Only migrate 'r' type users. |
| **first_name** | `restaurant_admins.fname` | Direct copy; varchar(20) → varchar(50) |
| **last_name** | `restaurant_admins.lname` | Direct copy; varchar(50) → varchar(50) |
| **email** | `restaurant_admins.email` | Direct copy; lowercase and trim. varchar(50) → varchar(255) |
| **password_hash** | `restaurant_admins.password` | Copy as-is (legacy bcrypt hashes with `$2y$10$` prefix). varchar(255) → varchar(255). **Note:** Passwords may need rehashing with modern algorithms later; this is a direct migration. |
| **last_login** | `restaurant_admins.lastlogin` | Direct copy; TIMESTAMP → TIMESTAMPTZ (UTC) |
| **login_count** | `restaurant_admins.loginCount` | Direct copy; INT UNSIGNED → INTEGER |
| **is_active** | `restaurant_admins.activeUser` | Map enum → boolean: '1' → true, '0' → false |
| **send_statement** | `restaurant_admins.sendStatement` | Map enum → boolean: 'y' → true, 'n' → false |
| **created_at** | `restaurant_admins.created_at` | Copy if present (added in later V1 versions); if NULL, use `lastlogin` or set to migration timestamp |
| **updated_at** | `restaurant_admins.updated_at` | Copy if present; if NULL, leave NULL (trigger will manage going forward) |

**Out of Scope (V1 columns not migrated to v3):**
- `admin_user_id`: Internal V1 reference, not needed in v3
- `allowed_restaurants`: BLOB field (PHP serialized array) for multi-restaurant access; contains serialized array of restaurant IDs like `a:847:{i:0;s:2:"72";i:1;s:2:"89";...}`. V3 will handle this via a separate `restaurant_admin_access` junction table (see **Multi-Restaurant Access Strategy** below).
- `showAllStats`, `fb_token`, `showOrderManagement`, `sendStatementTo`, `allowAr`, `showClients`: V1-specific UI/feature flags not applicable to v3 schema

**V2 Analysis:**
V2 `admin_users` represents a completely different entity:
- **84 platform administrators** with group-based permissions (groups 1, 2, 10, 12, 20)
- Cross-restaurant access via `admin_users_restaurants` junction table (432 mappings)
- These are **platform-level staff** (e.g., Stefan, Menu Ottawa, George, etc.), NOT restaurant owners
- Should **NOT** be migrated to `menuca_v3.restaurant_admin_users`
- If needed, V2 admin users would migrate to a separate global/platform admin system

### Multi-Restaurant Access Strategy

**Problem:** V1 `allowed_restaurants` BLOB field contains PHP serialized arrays indicating which additional restaurants a user can access beyond their primary `restaurant` FK. Example:
```
_binary 'a:847:{i:0;s:2:"72";i:1;s:2:"89";i:2;s:2:"90";...}'
```
This represents an array of 847 restaurant IDs that user can access.

**V3 Solution:** Create a junction table to handle many-to-many relationships:

```sql
CREATE TABLE IF NOT EXISTS menuca_v3.restaurant_admin_access (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  admin_user_id bigint NOT NULL REFERENCES menuca_v3.restaurant_admin_users(id) ON DELETE CASCADE,
  restaurant_id bigint NOT NULL REFERENCES menuca_v3.restaurants(id) ON DELETE CASCADE,
  granted_at timestamptz DEFAULT now() NOT NULL,
  granted_by integer,
  UNIQUE(admin_user_id, restaurant_id)
);
CREATE INDEX IF NOT EXISTS idx_admin_access_user ON menuca_v3.restaurant_admin_access(admin_user_id);
CREATE INDEX IF NOT EXISTS idx_admin_access_restaurant ON menuca_v3.restaurant_admin_access(restaurant_id);
```

**Migration Approach:**
1. First migrate primary restaurant access (Step 2 of this plan)
2. Separately parse `allowed_restaurants` BLOB and populate junction table
3. For 'g' (global) type users with `restaurant=0`, populate junction table with ALL their allowed restaurants

### Data Insights from SQL Dumps

Based on analysis of actual V1 and V2 data dumps:

**V1 `restaurant_admins` Observations:**
- Contains records with `user_type = 'g'` (global) and `restaurant = 0` (e.g., james@menu.ca with 2,125 login count)
- `allowed_restaurants` BLOB contains PHP serialized arrays like: `a:847:{i:0;s:2:"72";i:1;s:2:"89";...}` representing 847 restaurant IDs
- Passwords use bcrypt format: `$2y$10$...` (PHP bcrypt)
- Global admins have extensive multi-restaurant access (up to 847 restaurants in sample data)

**V2 `admin_users` Observations:**
- **84 platform administrator accounts** (NOT restaurant owners)
- Grouped by permission levels: group 1 (superadmin), group 2 (Menu Ottawa vendor), group 10 (vendor/owner), group 12 (vendor), group 20 (test)
- Examples of platform staff:
  - Stefan Dragos (superadmin, 2,125+ logins)
  - Menu Ottawa team members
  - System administrators
- **432 restaurant access mappings** in `admin_users_restaurants` junction table
- These users manage multiple restaurants across the platform (e.g., user 65 has access to 15+ restaurants)

**Key Distinction:**
- V1 `restaurant_admins`: Restaurant owners/managers who log in to manage **their** restaurant(s)
- V2 `admin_users`: Platform staff who log in to the admin panel to manage **all** restaurants

**Migration Implication:**
- Only V1 `restaurant_admins` with `user_type='r'` and `restaurant > 0` should migrate to `menuca_v3.restaurant_admin_users`
- V1 global admins (`user_type='g'`, `restaurant=0`) should be handled via junction table for multi-restaurant access
- V2 `admin_users` should be migrated to a separate **platform admin** system (out of scope for this migration)

### Notes

1. **Single Source:** Only V1 `restaurant_admins` is the source. V2 has no equivalent restaurant-owner table.

2. **FK Dependency:** `menuca_v3.restaurants` must be loaded first with `legacy_v1_id` populated.

3. **Uniqueness:** The target has a unique constraint `u_admin_email_per_restaurant(restaurant_id, email)`. If V1 data has duplicate `(restaurant, email)` pairs, apply deduplication logic (e.g., keep most recent `lastlogin` or lowest `id`).

4. **Password Security:** Migrated `password_hash` values are legacy bcrypt (`$2y$10$` prefix). Plan a password reset flow or rehashing strategy post-migration.

5. **Multi-Restaurant Users:** V1 `allowed_restaurants` BLOB field contains PHP serialized arrays of restaurant IDs. V3 handles this via a separate `restaurant_admin_access` junction table. For initial migration (Step 2), focus on the primary `restaurant` FK only. Handle multi-access in Step 5.

### Preconditions (Step 0)

- Ensure `extensions.uuid_generate_v4()` exists.
- Ensure `menuca_v3.restaurants` is loaded and contains legacy keys (`legacy_v1_id`).
- Verify `menuca_v3.set_updated_at()` trigger function exists.

### Staging (Step 1)

Create staging table reflecting V1 data:

```sql
CREATE SCHEMA IF NOT EXISTS staging;

DROP TABLE IF EXISTS staging.v1_restaurant_admin_users;
CREATE TABLE staging.v1_restaurant_admin_users (
  legacy_admin_id integer,
  legacy_v1_restaurant_id integer,
  user_type text,
  fname text,
  lname text,
  email text,
  password_hash text,
  lastlogin timestamptz,
  login_count integer,
  active_user text,
  send_statement text,
  created_at timestamptz,
  updated_at timestamptz
);
-- Load from CSV or direct V1 DB link
```

Optional cleanup during load:

```sql
UPDATE staging.v1_restaurant_admin_users
SET email = lower(NULLIF(trim(email), '')),
    fname = NULLIF(trim(fname), ''),
    lname = NULLIF(trim(lname), ''),
    user_type = COALESCE(NULLIF(trim(user_type), ''), 'r');
```

### Transform and Upsert (Step 2) — Idempotent

Upsert key: `(restaurant_id, email)` per unique index.

**IMPORTANT:** Filter out `user_type='g'` with `restaurant=0` (global admins). These should be handled via the multi-restaurant access junction table instead.

```sql
BEGIN;

-- Ensure unique index exists
CREATE UNIQUE INDEX IF NOT EXISTS u_admin_email_per_restaurant
  ON menuca_v3.restaurant_admin_users (restaurant_id, email);

WITH base AS (
  SELECT
    s.legacy_admin_id,
    r.id AS restaurant_id,
    COALESCE(s.user_type, 'r') AS user_type,
    s.fname AS first_name,
    s.lname AS last_name,
    lower(trim(s.email)) AS email,
    s.password_hash,
    s.lastlogin AS last_login,
    s.login_count,
    CASE WHEN s.active_user = '1' THEN true ELSE false END AS is_active,
    CASE WHEN s.send_statement = 'y' THEN true ELSE false END AS send_statement,
    COALESCE(s.created_at, s.lastlogin, now()) AS created_at,
    s.updated_at
  FROM staging.v1_restaurant_admin_users s
  JOIN menuca_v3.restaurants r
    ON r.legacy_v1_id = s.legacy_v1_restaurant_id
  WHERE s.legacy_v1_restaurant_id > 0  -- Exclude global admins with restaurant=0
    AND COALESCE(s.user_type, 'r') = 'r'  -- Only restaurant-level admins
), ranked AS (
  -- Deduplicate by (restaurant_id, email) - keep most recent lastlogin
  SELECT b.*,
         row_number() OVER (
           PARTITION BY restaurant_id, email
           ORDER BY last_login DESC NULLS LAST, legacy_admin_id
         ) AS rn
  FROM base b
)
INSERT INTO menuca_v3.restaurant_admin_users (
  restaurant_id, user_type, first_name, last_name, email,
  password_hash, last_login, login_count, is_active, send_statement,
  created_at, updated_at
)
SELECT
  restaurant_id, user_type, first_name, last_name, email,
  password_hash, last_login, login_count, is_active, send_statement,
  created_at, updated_at
FROM ranked
WHERE rn = 1
ON CONFLICT (restaurant_id, email)
DO UPDATE SET
  user_type = COALESCE(EXCLUDED.user_type, menuca_v3.restaurant_admin_users.user_type),
  first_name = COALESCE(EXCLUDED.first_name, menuca_v3.restaurant_admin_users.first_name),
  last_name = COALESCE(EXCLUDED.last_name, menuca_v3.restaurant_admin_users.last_name),
  password_hash = COALESCE(EXCLUDED.password_hash, menuca_v3.restaurant_admin_users.password_hash),
  last_login = GREATEST(EXCLUDED.last_login, menuca_v3.restaurant_admin_users.last_login),
  login_count = EXCLUDED.login_count,
  is_active = EXCLUDED.is_active,
  send_statement = EXCLUDED.send_statement,
  updated_at = now();

COMMIT;
```

### Post-load Normalization (Step 3)

Optional: Normalize email formats and check for orphaned accounts.

```sql
-- Verify all emails are lowercase and trimmed (should be handled in Step 2)
SELECT restaurant_id, email
FROM menuca_v3.restaurant_admin_users
WHERE email != lower(trim(email));

-- Check for admin users with no active restaurant link
SELECT au.id, au.email, au.restaurant_id
FROM menuca_v3.restaurant_admin_users au
LEFT JOIN menuca_v3.restaurants r ON r.id = au.restaurant_id
WHERE r.id IS NULL;
```

### Verification (Step 4)

```sql
-- A) Source vs target counts
SELECT COUNT(*) AS v1_admin_users FROM staging.v1_restaurant_admin_users;
SELECT COUNT(*) AS v3_admin_users FROM menuca_v3.restaurant_admin_users;

-- B) Broken FK (should be zero)
SELECT s.legacy_v1_restaurant_id, COUNT(*) as cnt
FROM staging.v1_restaurant_admin_users s
LEFT JOIN menuca_v3.restaurants r ON r.legacy_v1_id = s.legacy_v1_restaurant_id
WHERE r.id IS NULL
GROUP BY s.legacy_v1_restaurant_id;

-- C) Duplicate (restaurant_id, email) pairs in source (pre-dedupe analysis)
WITH src AS (
  SELECT r.id AS restaurant_id,
         lower(trim(s.email)) AS email
  FROM staging.v1_restaurant_admin_users s
  JOIN menuca_v3.restaurants r ON r.legacy_v1_id = s.legacy_v1_restaurant_id
)
SELECT restaurant_id, email, COUNT(*) as cnt
FROM src
GROUP BY restaurant_id, email
HAVING COUNT(*) > 1;

-- D) Verify unique constraint in target (should be zero)
SELECT restaurant_id, email, COUNT(*) as cnt
FROM menuca_v3.restaurant_admin_users
GROUP BY restaurant_id, email
HAVING COUNT(*) > 1;

-- E) Distribution check
SELECT
  SUM(CASE WHEN user_type = 'r' THEN 1 ELSE 0 END) AS restaurant_type,
  SUM(CASE WHEN user_type = 'g' THEN 1 ELSE 0 END) AS global_type,
  SUM(CASE WHEN is_active = true THEN 1 ELSE 0 END) AS active_users,
  SUM(CASE WHEN is_active = false THEN 1 ELSE 0 END) AS inactive_users,
  SUM(CASE WHEN send_statement = true THEN 1 ELSE 0 END) AS receives_statements
FROM menuca_v3.restaurant_admin_users;

-- F) Sample join to restaurant names
SELECT au.*, r.name AS restaurant_name
FROM menuca_v3.restaurant_admin_users au
JOIN menuca_v3.restaurants r ON r.id = au.restaurant_id
ORDER BY r.name, au.email
LIMIT 50;
```

Remediation tips:
- Any rows reported by (B) require adding the missing restaurants to `menuca_v3.restaurants` or fixing legacy links.
- Rows flagged by (C) will be automatically deduplicated in Step 2 (keeping most recent `last_login`).

### Multi-Restaurant Access Migration (Step 5) — Optional

If multi-restaurant access is required, migrate V1 `allowed_restaurants` BLOB data to the junction table.

#### Preconditions
- Step 2 must be completed (primary restaurant admin users migrated)
- `menuca_v3.restaurant_admin_access` junction table created (see DDL in **Multi-Restaurant Access Strategy** section)

#### Migration Script

**Note:** V1 `allowed_restaurants` contains PHP serialized arrays. Parse these using a PHP script or PostgreSQL parsing logic.

Example using Python helper script:

```python
import mysql.connector
import psycopg2
import pickle
import phpserialize

# Connect to V1 MySQL and V3 PostgreSQL
v1_conn = mysql.connector.connect(host='localhost', user='root', password='', database='menuca_v1')
v3_conn = psycopg2.connect(host='localhost', user='postgres', password='', database='menuca_v3')

v1_cursor = v1_conn.cursor()
v3_cursor = v3_conn.cursor()

# Read V1 admin users with allowed_restaurants
v1_cursor.execute("""
    SELECT id, restaurant, email, allowed_restaurants 
    FROM restaurant_admins 
    WHERE allowed_restaurants IS NOT NULL AND allowed_restaurants != ''
""")

for v1_id, v1_restaurant_id, email, allowed_blob in v1_cursor.fetchall():
    try:
        # Parse PHP serialized array
        allowed_ids = phpserialize.loads(allowed_blob)
        
        # Get v3 admin_user_id
        v3_cursor.execute("""
            SELECT au.id 
            FROM menuca_v3.restaurant_admin_users au
            JOIN menuca_v3.restaurants r ON r.id = au.restaurant_id
            WHERE au.email = %s AND r.legacy_v1_id = %s
        """, (email.lower(), v1_restaurant_id))
        
        result = v3_cursor.fetchone()
        if not result:
            print(f"No v3 user found for {email}, skipping")
            continue
        
        v3_admin_user_id = result[0]
        
        # Insert access records for each allowed restaurant
        for rest_id in allowed_ids.values():
            rest_id_str = rest_id.decode('utf-8') if isinstance(rest_id, bytes) else rest_id
            
            v3_cursor.execute("""
                INSERT INTO menuca_v3.restaurant_admin_access (admin_user_id, restaurant_id)
                SELECT %s, r.id
                FROM menuca_v3.restaurants r
                WHERE r.legacy_v1_id = %s
                ON CONFLICT (admin_user_id, restaurant_id) DO NOTHING
            """, (v3_admin_user_id, int(rest_id_str)))
        
        v3_conn.commit()
        print(f"Migrated {len(allowed_ids)} access records for {email}")
        
    except Exception as e:
        print(f"Error processing {email}: {e}")
        v3_conn.rollback()

v1_conn.close()
v3_conn.close()
```

Alternatively, use PostgreSQL with a staging table approach:

```sql
-- Step 5a: Create staging for parsed allowed_restaurants
CREATE TABLE IF NOT EXISTS staging.v1_admin_allowed_restaurants (
  v1_admin_id integer,
  v1_restaurant_id integer,  -- Primary restaurant FK
  email text,
  allowed_restaurant_ids integer[]  -- Array of allowed restaurant IDs
);

-- Load parsed data (use external script to parse PHP serialized BLOBs and insert here)
-- Example row: (20, 0, 'james@menu.ca', ARRAY[72, 89, 90, 94, 95, ...])

-- Step 5b: Populate junction table
INSERT INTO menuca_v3.restaurant_admin_access (admin_user_id, restaurant_id, granted_at)
SELECT DISTINCT
  au.id AS admin_user_id,
  r.id AS restaurant_id,
  now() AS granted_at
FROM staging.v1_admin_allowed_restaurants s
JOIN menuca_v3.restaurant_admin_users au 
  ON au.email = lower(trim(s.email))
CROSS JOIN LATERAL unnest(s.allowed_restaurant_ids) AS allowed_id
JOIN menuca_v3.restaurants r 
  ON r.legacy_v1_id = allowed_id
WHERE au.restaurant_id IS NOT NULL  -- Ensure we have a valid admin user
ON CONFLICT (admin_user_id, restaurant_id) DO NOTHING;
```

#### Verification for Step 5

```sql
-- Count of multi-access relationships
SELECT COUNT(*) AS total_access_grants
FROM menuca_v3.restaurant_admin_access;

-- Users with access to multiple restaurants
SELECT au.email, au.restaurant_id AS primary_restaurant, COUNT(ara.restaurant_id) AS additional_access_count
FROM menuca_v3.restaurant_admin_users au
JOIN menuca_v3.restaurant_admin_access ara ON ara.admin_user_id = au.id
WHERE ara.restaurant_id != au.restaurant_id  -- Exclude their primary restaurant
GROUP BY au.email, au.restaurant_id
HAVING COUNT(ara.restaurant_id) > 0
ORDER BY additional_access_count DESC;
```

### Execution Order

1) Run Preconditions (Step 0).
2) Load staging (Step 1).
3) Execute Transform/Upsert (Step 2) - primary restaurant admin users.
4) Run Post-load normalization (Step 3) [optional].
5) Run Verification (Step 4) and remediate as needed; steps are idempotent.
6) **[OPTIONAL]** Run Multi-Restaurant Access Migration (Step 5) if multi-restaurant functionality is required.

### Out-of-Scope for Initial Migration

- V2 `admin_users` (platform-level administrators, not restaurant-specific) - requires separate global admin system
- V1 feature flags (`showAllStats`, `showOrderManagement`, etc.) - UI-specific, not applicable to v3 schema
- Password rehashing/reset flow (post-migration security enhancement) - handle via application layer


